# -----------------------------------------------------------------------------------------#
#
# PE/Malware Analysis Tool
#
# Description: Create reports of portable executable files (PE) and reverse engineer the code to assembly language.
# Author: Nicholas Kluge CorrÃªa
# E-mail: nicholas@airespucrs.org
# Source: https://github.com/Nkluge-correa/teeny-tiny_castle
#
# -----------------------------------------------------------------------------------------#

import pefile
import hashlib
import argparse
import capstone as cs


def malware_analysis(path):
    pe = pefile.PE(path)

    with open('pe_dump.txt', 'w') as f:
        f.write(pe.dump_info())

    print("Full PE dump info saved in 'pe_dump.txt'")

    def md5(path):
        hash_md5 = hashlib.md5()
        with open(path, "rb") as f:
            for chunk in iter(lambda: f.read(4096), b""):
                hash_md5.update(chunk)
        return hash_md5.hexdigest()

    with open('pe_summary.txt', 'w') as f:
        f.write('PE Summary Report\n\n')
        f.write(f'DOS HEADER\n')
        f.write(f'{"*" * 50} \n\n')
        # Prints the e_magic field of the DOS_HEADER
        f.write(f"e_magic : {hex(pe.DOS_HEADER.e_magic)} \n")
        # Prints the e_lfnew field of the DOS_HEADER
        f.write(f"e_lfnew : {hex(pe.DOS_HEADER.e_lfanew)} \n")
        f.write(f'\nNT HEADER\n')
        f.write(f'{"*" * 50} \n\n')
        # Prints the Signature field of the NT_HEADERS
        f.write(f"Signature : {hex(pe.NT_HEADERS.Signature)} \n")
        f.write(f'\nFILE HEADER\n')
        f.write(f'{"*" * 50} \n\n')
        f.write(f"Machine : {hex(pe.FILE_HEADER.Machine)} '\n")
        # Check if it is a 32-bit or 64-bit binary
        if hex(pe.FILE_HEADER.Machine) == '0x14c':
            f.write(f"This is a 32-bit binary\n")
        else:
            f.write(f"This is a 64-bit binary\n")
        f.write(
            f"TimeDateStamp : {pe.FILE_HEADER.dump_dict()['TimeDateStamp']['Value'].split('[')[1][:-1]} \n")
        f.write(
            f"NumberOfSections : {hex(pe.FILE_HEADER.NumberOfSections)} \n")
        f.write(
            f"Characteristics flags : {hex(pe.FILE_HEADER.Characteristics)} \n")
        f.write(f'\nOPTIONAL HEADER\n')
        f.write(f'{"*" * 50} \n\n')
        f.write(f"Magic : {hex(pe.OPTIONAL_HEADER.Magic)} \n")
        # Check if it is a 32-bit or 64-bit binary
        if hex(pe.OPTIONAL_HEADER.Magic) == '0x10b':
            f.write(f"This is a 32-bit binary\n")
        elif hex(pe.OPTIONAL_HEADER.Magic) == '0x20b':
            f.write(f"This is a 64-bit binary\n")
        f.write(f"ImageBase : {hex(pe.OPTIONAL_HEADER.ImageBase)} \n")
        f.write(
            f"SectionAlignment : {hex(pe.OPTIONAL_HEADER.SectionAlignment)} \n")
        f.write(f"FileAlignment : {hex(pe.OPTIONAL_HEADER.FileAlignment)} \n")
        f.write(f"SizeOfImage : {hex(pe.OPTIONAL_HEADER.SizeOfImage)} \n")
        f.write(
            f"DllCharacteristics flags : {hex(pe.OPTIONAL_HEADER.DllCharacteristics)} \n")
        f.write(f'\nDATA DIRECTORY\n')
        f.write(f'{"*" * 50} \n\n')
        # print name, size and virtualaddress of every DATA_ENTRY in DATA_DIRECTORY
        for entry in pe.OPTIONAL_HEADER.DATA_DIRECTORY:
            f.write(
                f"{entry.name} \n|\n|---- Size : {str(entry.Size)} \n|\n|---- VirutalAddress : {hex(entry.VirtualAddress)} \n")
        f.write(f'{"*" * 50} \n\n')
        f.write("SECTIONS INFO: \n")
        f.write(f'{"*" * 50} \n\n')
        for section in pe.sections:
            f.write(section.Name.decode().rstrip('\x00') + "\n|\n|---- Vitual Size : " + hex(section.Misc_VirtualSize) + "\n|\n|---- VirutalAddress : " + hex(section.VirtualAddress) +
                    "\n|\n|---- SizeOfRawData : " + hex(section.SizeOfRawData) + "\n|\n|---- PointerToRawData : " + hex(section.PointerToRawData) + "\n|\n|---- Characterisitcs : " + hex(section.Characteristics)+'\n')
        f.write(f'{"*" * 50} \n\n')
        f.write(f"File Checksum : {md5(path)}.\n")
        f.write(f'{"*" * 50} \n\n')

    print("Summary of the PE saved in 'pe_summary.txt'")
    print(f"File Checksum : {md5(path)}.")

    ADDRESS = 0x1000

    ep = pe.OPTIONAL_HEADER.AddressOfEntryPoint
    data = pe.get_memory_mapped_image(
    )[ep:ep+len(pe.get_memory_mapped_image())]

    engine = cs.Cs(cs.CS_ARCH_X86, cs.CS_MODE_32)

    with open('assembly_program.asm', 'w') as f:
        for inst in engine.disasm(data, ADDRESS):
            f.write(f'0x{inst.address}: \t{inst.mnemonic} \t{inst.op_str}\n')
    print("Full assembly program saved in 'assembly_program.asm'")


def main():
    parser = argparse.ArgumentParser(
        description="PE/Malware Analysis Tool - By Nicholas Kluge")
    parser.add_argument('-P', '--path', required=True,
                        help='Path to the file.exe location, e.g., executable\\file.exe')
    args = parser.parse_args()

    try:
        malware_analysis(args.path)
    except:
        print(
            f'Error: could not find .exe file in specified location --> "{args.path}"')


if __name__ == '__main__':
    main()
